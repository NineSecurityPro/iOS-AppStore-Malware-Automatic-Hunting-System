#!/usr/bin/python

###
 # Copyright (c) 2016 Nishant Das Patnaik.
 #
 # Licensed under the Apache License, Version 2.0 (the "License");
 # you may not use this file except in compliance with the License.
 # You may obtain a copy of the License at
 #
 #  http://www.apache.org/licenses/LICENSE-2.0
 #
 # Unless required by applicable law or agreed to in writing, software
 # distributed under the License is distributed on an "AS IS" BASIS,
 # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 # See the License for the specific language governing permissions and
 # limitations under the License.
###

import os, sys, argparse, time, codecs, binascii, frida, json, traceback, subprocess
from flask import Flask, request, render_template
from termcolor import colored
import database as db
from datetime import datetime
 

 
class Tracer:
    def init(self,host_name,app_name, pid=None,platform='',spawn=0, script_path='', output_dir=''):
        self.terminated=False
        self.output_dir = ''
        self.platform = ''
        self.device =None
        self.session =None
        self.host_name=''
        self.app_name=''
        self.pid=None
        self.merged_script_path = '/tmp/merged.js'
        #self.APP_LIST = []
        self.spawn=0
        self.script_path=''
        self.script=None
        self.messages=[]

        self.host_name = host_name
        self.app_name = app_name
        self.pid = pid
        self.platform = platform
        self.spawn=spawn
        self.script_path=script_path
        self.output_dir = output_dir

    def __init__(self):
        self.terminated=False
        self.output_dir = ''
        self.platform = ''
        self.session =None
        self.device =None
        self.host_name=''
        self.app_name=''
        self.pid=None
        self.merged_script_path = '/tmp/merged.js'
        #self.APP_LIST = []
        self.spawn=0
        self.script_path=''
        self.script=None
        self.messages=[]



    #on Event handler zone
    def on_detached(self):
        self.terminated = True
        print colored('[WARNING] "on_detached:%s" has terminated!' % (self.app_name), 'red')

    def on_detached_with_reason(self, reason):
        self.terminated = True
        print colored('[WARNING] "on_detached_with_reason:%s" !' % (reason), 'red')

    def on_detached_with_varargs(self, *args):
        self.terminated = True
        print colored('[WARNING] "on_detached_with_varargs:%s" !' % (args), 'red')

    def on_detach_with_message_data(self,  message, data):
        self.terminated = True
        self.save_messages(self.messages)

        print colored('[WARNING] "on_detach_with_message_data:     |- Process :(%s,\t%s)" ' % (self.app_name, message.pid), 'red')
        print colored('[WARNING] "on_detach_with_message_data:     |- Detach Reason: %s" ' % (data), 'red')
        if ("process-terminated" == data):
            pass
        
        

    def on_lost(self):
        self.terminated = True
        if self.session:
            print("session={0} on_lost: Device Disconnected.".format(self.session))

    def on_output(self,  pid, fd, data):
        if not data:
            return

        lmod = " [!] stderr"

        if fd == 1:
            lmod = " [*] stdout"

        data = data.split('\n')
        for line in data:
            print ' %s> %s' % (lmod, line)

    def on_message(self, message, data):
        #print ("one_message:\r\n{0}\t{1}".format(message, data))
        if not os.path.exists(self.output_dir):
            os.makedirs(self.output_dir)

        if message['type'] == 'send':
            #dbName = "{0}-{1}".format(self.app_name, self.pid)
            #save to db
            #writePath = os.path.join(self.output_dir, str(dbName) + '.db')
            #db.save_to_database(writePath, message['payload'])

            #save to json
            #writePath = os.path.join(self.output_dir, dbName + '.json')
            #self.writeBinFile(writePath, message['payload']) 
            ######self.writeBinFile(writePath, binascii.unhexlify(message['payload']))
            self.messages.append(message['payload'])
            #print self.messages

            print colored('%s\r\n' % (message['payload']), 'green')
            #print '[%s] Dumped to %s' % (current_time, writePath)
            
        elif message['type'] == 'error':
            print(message['stack'])


    #Utility zone
    def generate_injection(self, script_path):
        injection_source = ''
        if os.path.isfile(script_path):
            with codecs.open(script_path, 'r', 'utf-8') as f:
                injection_source = f.read()
        elif os.path.isdir(script_path):
            with codecs.open(self.merge_scripts(script_path), 'r', 'utf-8') as f:
                injection_source = f.read()
        print colored('[INFO] Building injection...', 'yellow')
        return injection_source

    def getDisplayName(self, session, app_name, platform):
        try:
            str_script = ""
            if platform == "ios":
                str_script = """/* ____CFBundleDisplayName Getter for iOS Gadget____ */
    'use strict';
    rpc.exports = {
      gadgetdisplayname: function () {
        if (ObjC.available) {
          var dict = ObjC.classes.NSBundle.mainBundle().infoDictionary();
          var iter = dict.keyEnumerator();
          var key = "";
          while ((key = iter.nextObject()) !== null) {
            if (key.toString() === "CFBundleDisplayName") {
              return dict.objectForKey_(key).toString();
            }
          }
        } else { return null; }
      }
    };
    """
                script = session.create_script(str_script)
                script.load()
                if script.exports.gadgetdisplayname:
                    app_name = script.exports.gadgetdisplayname()
                script.unload()
                return app_name
            elif platform == "android":
                str_script = """/* ____ getPackageName Getter for Android Gadget____ */
    'use strict';
    rpc.exports = {
      gadgetdisplayname: function () {
        var appName = "";
        Java.perform(function(argument) {
            const ActivityThread = Java.use('android.app.ActivityThread');
            const app = ActivityThread.currentApplication();
            appName = app.toString().split("@")[0];
        });
        return appName;
    }};
    """
                script = session.create_script(str_script)
                script.load()
                if script.exports.gadgetdisplayname:
                    app_name = script.exports.gadgetdisplayname()
                script.unload()
                return app_name
        except Exception as e:
            print colored("[ERROR] " + str(e), "red")
            traceback.print_exc()

    def getBundleID(self, device, app_name, platform):
        try:
            session = device.attach(app_name)
            session.on('detached', on_detached)
            script = session.create_script("""'use strict';
    rpc.exports = {
      iosbundleid: function () {
        return ObjC.classes.NSBundle.mainBundle().bundleIdentifier().toString();
      },
      macosbundleid: function () {
        return ObjC.classes.NSBundle.mainBundle().executablePath().toString();
      }
    };
    """)
            script.load()
            if platform == 'ios':
                bundleID = script.exports.iosbundleid()
            elif platform == 'macos':
                bundleID = script.exports.macosbundleid()
            script.unload()
            session.detach()
            return bundleID
        except Exception as e:
            print colored("[ERROR] " + str(e), "red")
            traceback.print_exc()



    #Methods
    def merge_scripts(self, path):
        script_source = ''
        for root, dirs, files in os.walk(path):
            path = root.split('/')
            for file in files:
                script_path = os.path.join(root, file)
                if -1 == script_path.find('moony-disable-'):
                #moony hack:
                    if script_path.endswith('.js'):
                        source = ''
                        with codecs.open(script_path, 'r', 'utf-8') as f:
                            source = f.read()
                        script_source += '/* ____%s/%s____ */\n\n' % (os.path.basename(root), file) + source + '\n\n'
        with codecs.open(self.merged_script_path, "w", "utf-8") as f:
            f.write(script_source)
        return self.merged_script_path

    def _exit_(self):
        print colored('[INFO] Exiting...', 'green')
        try:
            os.remove(merged_script_path)
        except Exception as e:
            pass
        #sys.exit(0)

    def writeBinFile(self, fname, data):
        with codecs.open(fname, "a", "utf-8") as f:
            for item in data:
                f.write(item + '\r\n')


    def list_processes(self, session):
        print 'PID\tProcesses\n', '===\t========='
        for app in session.enumerate_processes():
            print "%s\t%s" % (app.pid, app.name)

    def init_session(self):

        self.terminated = False
        self.messages=[]
        
        print colored('init_session enter: device {0} session {1}'.format(self.device, self.session), 'green')

        if self.device:
            print colored('device {0} is already initiated'.format(self.device), 'green')
        else:
        #try to get device 
            #moony hacker for host name:
            if self.host_name:
            #host mode
                try:
                    self.device = frida.get_device_manager().add_remote_device(self.host_name);
                    print colored("get device ({0}) from host_name {1}".format(self.device, self.host_name), "green")
                except Exception as e:
                    print colored('[ERROR] ' + str(e), 'red')
                    traceback.print_exc()

            else:
                #usb mode by default
                #print "init_sessions:\t{0}\t".format(platform)
                if self.platform == 'ios' or self.platform == 'android':
                    try:
                        self.device = frida.get_usb_device(3) # added timeout to wait for 3 seconds
                    except Exception as e:
                        print colored(str(e), "red")
                        traceback.print_exc()
                        if self.platform == 'android':
                            print colored("Troubleshooting Help", "blue")
                            print colored("HINT: Is USB Debugging enabled?", "blue")
                            print colored("HINT: Is `frida-server` running on mobile device (with +x permissions)?", "blue")
                            print colored("HINT: Is `adb` daemon running?", "blue")
                            #sys.exit(1)
                        elif self.platform == "ios":
                            print colored("Troubleshooting Help", "blue")
                            print colored("HINT: Have you installed `frida` module from Cydia?", "blue")
                            print colored("HINT: Have used `ipa_installer` to inject the `FridaGadget` shared lbrary?", "blue")
                            #sys.exit(1)
                elif self.platform == 'macos':
                    self.device = frida.get_local_device()
                else:
                    print colored('[ERROR] Unsupported Platform', 'red')
                    #sys.exit(1)

        if self.device:
            print colored('init device {0}'.format(self.device), 'green')
        else:
            print colored('[ERROR] init device failed, exit ', 'red')
            return 



        if self.app_name:
            try:
                if self.platform == 'android' and spawn == 1:
                    print colored("Now Spawning %s" % self.app_name, "green")
                    self.pid = device.spawn([self.app_name])
                    #time.sleep(5)
                    self.session = device.attach(pid)
                    #time.sleep(5)
                elif (self.platform == 'ios' or self.platform == 'macos') and self.spawn == 1:
                    bundleID = self.getBundleID(self.device, self.app_name, self.platform)
                    if bundleID:
                        print colored("Now Spawning %s" % bundleID, "green")
                        self.pid = self.device.spawn([bundleID])
                        #time.sleep(5)
                        self.session = self.device.attach(self.pid)
                    else:
                        print colored("[ERROR] Can't spawn %s" % app_name, "red")
                        traceback.print_exc()
                        #sys.exit(1)
                else:
                    print colored("Now Spawning %s" % self.app_name, "green")
                    self.pid = self.device.spawn([self.app_name])

                    print colored("[ERROR] spawn %d" % self.pid, "red")
                    # time.sleep(5)
                    self.session = self.device.attach(self.pid)
                    self.spawn = 1

                """
                else:
                    print colored('[INFO] attach app_name={0} on device= {1}'.format(
                            self.app_name, self.device), 'yellow')
                    self.session = self.device.attach(self.app_name)

                    self.pid = self.device.get_process(self.app_name).pid
                    print ("get_process:{0}->{1}".format(self.app_name, self.pid))
                """
             
            except Exception as e:
                print colored('[ERROR] ' + str(e), 'red')
                traceback.print_exc()
        else:
            try:
                if self.pid != -1:
                    self.session = self.device.attach(self.pid)
            except Exception as e:
                print colored('[ERROR] ' + str(e), 'red')
                traceback.print_exc()
     


        try:    
            if self.session:
                print colored('[INFO] Attached to {0} with session {1}'.format(self.app_name, self.session), 'yellow')
                #session.on('detached', on_detached)
                #session.on('detached', on_detached_with_reason)
                #session.on('detached', on_detached_with_varargs)
                self.session.on('detached', self.on_detach_with_message_data)
                
                if self.device:
                    #device.on('output', self.on_output)
                    self.device.on('lost', self.on_lost)
        except Exception as e:
            print colored('[ERROR] ' + str(e), 'red')
            traceback.print_exc()

        #end of init_sessions()

    def save_messages(self,  messages):     
        try:
            current_time = time.strftime('%b %d %Y %l:%M %p', time.localtime())
            dbName = "{0}-{1}".format(self.app_name, self.pid)
            #save to json
            writePath = os.path.join(self.output_dir, dbName + '.json')
            #print messages
            self.writeBinFile(writePath, messages) 
            print colored('[INFO] %s\tAll messages dumped to %s' % (current_time, writePath), 'yellow')

        except Exception as e:
            print colored('[ERROR] ' + str(e), 'red')
            traceback.print_exc()
 

    def start(self):
    
        counter = 0
        self.session = None
        self.device = None
        try:
            while True:
                self.init_session()

                if self.session and self.device :
                    if self.app_name == "Gadget":
                        self.app_name = self.getDisplayName(self.session, self.app_name, self.platform)
                    self.script = self.session.create_script(self.generate_injection(self.script_path))
                    if self.script :
                        print colored('[INFO] app_name({0}), session({1}): Instrumentation started...'.format(self.app_name, self.session), 'yellow')
                        self.script.on('message', self.on_message)
                        self.script.load()
                        
                        if self.spawn == 1 and self.pid:
                            self.device.resume(self.pid)
                if self.session:
                    break

                print colored('[INFO] counter={0}, app_name({1}),pid={2}, device {3}, session({4}), try init session again...'.format(
                        counter, self.app_name,
                        self.pid,
                        self.device,
                        self.session), 'yellow')
                counter = counter + 1

                import time
                time.sleep(10)
                #break

        except Exception as e:
            print colored('[ERROR] ' + str(e), 'red')
            traceback.print_exc()
            #sys.exit(1)



    def stop(self):
        try:
            #if self.script:
            #    self.script.unload()

            if self.session:
                self.session.detach()

        except Exception as e:
            print colored('[ERROR] ' + str(e), 'red')
            traceback.print_exc()
            #sys.exit(1)


#global methods zone
def init_opts():
    apps_configs = []
    parser = argparse.ArgumentParser()
    parser.add_argument('-H', action='store', dest='host_name', default='',
                    help='''Host Name;
                    connect to remote frida-server on HOST''')

    parser.add_argument('-a', action='store', dest='app_name', default='',
                    help='''Process Name;
                    Accepts "Twitter" for iOS; 
                    "com.twitter.android" for Android; "Twitter" for macOS''')
    parser.add_argument('--spawn', action='store', dest='spawn', default=0,
                    help='''Optional; Accepts 1=Spawn, 0=Attach; Needs "-p PLATFORM"''')
    parser.add_argument('-p', action='store', dest='platform',
                    help='Platform Type; Accepts "ios", "android" or "macos"')
    parser.add_argument('-s', action='store', dest='script_path', default='',
                    help='''Path to agent script file;
                    Can be relative/absolute path for a file or directory;
                    Multiple scripts in a directory shall be merged;
                    Needs "-a APP_NAME"''')
    parser.add_argument('-o', action='store', dest='output_dir',
                    help='''(Optional) Path to store any dumps/logs;
                    Accepts relative/absolute paths''')
    parser.add_argument('-ls', action='store', dest='list_apps', default=0,
                    help='''Optional; Accepts 1 or 0; Lists running Apps on target device; Needs "-p PLATFORM"''')
    parser.add_argument('-v', action='version', version='AppMon Sniffer v0.1, Nishant Das Patnaik, 2016')

    if len(sys.argv) == 1:
        parser.print_help()
        #sys.exit(1)

    results = parser.parse_args()
    host_name = results.host_name
    app_name = results.app_name
    platform = results.platform
    script_path = results.script_path
    list_apps = int(results.list_apps)
    spawn = int(results.spawn)
    
    output_dir = results.output_dir if results.output_dir else './app_dumps'

    if script_path != None and app_name == '' and list_apps == 0:
        parser.print_help()
        sys.exit(1)
    
    #apps_configs.append(("Mail", spawn, script_path))
    #apps_configs.append((host_name, app_name, spawn, script_path))
    osxProcessNameList=["Wi-Fi", "FindMyMacd", "ocspd","syspolicyd", "com.apple.AmbientDisplayAgent",
    "installerdiagd", "SubmitDiagInfo", "spindump", "mdflagwriter",
    "wifivelocityd","suhelperd", "smd", "filecoordinationd", "system_installd",
    "installd", "TMCacheDelete", "WirelessRadioManagerd",
    "securityd_service", "watchdogd", "com.apple.GSSCred", 
    "cooreauthd", "com.apple.AccountPolicyHelper","tccd",
    "systemsoundserverd","secinitd","ctkahp", "sharedfilelistd",
    "taskgated", "amfid", "com.apple.CodeSigningHelper",
     "CVMServer", "akd", "sysmond",
     "com.apple.PerformanceAnalysis.animationperfd","ntpd","ethcheck",
     "com.apple.ifdreader","usbd", "nehelper", "CrashReporterSupportHelper",
     "coresymbolicationd", "systemstats","mds_stores",
     "findmydeviced","awdd", "mDNSResponderHelper",
     "lsd", "sandboxd","trustd","authd","aslmanager",
     "coreservicesd","cfprefsd","notifyd","AirPlayXPCHelper","corebrightnessd",
     "KernelEventAgent","logind","revisiond","kdc",
     "autofsd", "blued", "DueHeuristic-BM",
     "securityd", "com.apple.ctkpcscd","launchservicesd",
     "nbstated", "apsd", "wirelessproxd", "iconservicesagent",
     "mds","warmd", "airportd", "logd", "mobileassetd", 
     "powerd", "configd", "mediaremoted", "fseventsd", 
     "kextd", "uninstalld", "syslogd", "UserEventAgent", 
     "ocspd", "storeinstalld", 

     "symptomsd","appleeventsd", "mDNSResponder", 
     "WindowServer", "mdworkder", "distnoted",
     "trustd", "softwareupdated", "coreaudiod", "com.apple.audio.DriverHelper", 
     "locationd", "netbiosd", "usbmuxd", "AssetCacheLocatorService", "AssetCache",
     "iconservicesd", "distnoted", "nsurlsessiond", "nsurlstoraged",
     "displaypolicyd", "captiveagent", "ctkd", "hidd"];
    
    #install profile at /var/mobile/Library/ConfigurationProfiles/profile-4ecba0b5def636872b1da380625035b4adfb4c5f4f38788cf1774579fe90dd3c.stub
    #iosProfileProcessNameList=[ "profiled", "callservicesd", "mDNSResponder", "launchd"]
    #test
    #iosProfileProcessNameList=[ "callservicesd", "mDNSResponder"]
    #iosProfileProcessNameList=[ "Preferences", "misagent"]
    #iosProfileProcessNameList=[ "itunescloudd"]
    #iosProfileProcessNameList=[ "Safari","Mail"]
    #iosProfileProcessNameList=[ "launchd"]
    #iosProfileProcessNameList=[ "lsd","kernel_task"]
    #iosProfileProcessNameList=[ "lsd"]
    #iosProfileProcessNameList=[ "online-auth-agen"]
    
    #iosProfileProcessNameList=[ "Safari"]
    #iosProfileProcessNameList=[ "lockdownd"]
    #
    #iosProfileProcessNameList=[ "Settings"]
    #Preferences
    #iosProfileProcessNameList=[ "SpringBoard"]
    #iosProfileProcessNameList=[ "online-auth-agent"]
    
    #iosProfileProcessNameList=[ "ImplantatPass"]
    #iosProfileProcessNameList=[ "profiled", "Mail", "Safari"]
    #iosProfileProcessNameList=[ "Mail", "profiled"]
    #iosProfileProcessNameList=[ "Mail"]
    #iosProfileProcessNameList=[ "profiled", "Mail"]
    iosProfileProcessNameList=[ "re.frida.Gadget"]
    
    
    #iosProfileProcessNameList=[ "misagent"]
    #iosProfileProcessNameList=[ "Safari", "lockdownd", "lsd"]
    #iosProfileProcessNameList=[ "profiled", "lockdownd", "Mail"]
    #iosProfileProcessNameList=["Safari", "Mail", "profiled", "launchd"]
    #for procName in osxProcessNameList:
    for procName in iosProfileProcessNameList:
        apps_configs.append((host_name, procName,-1, spawn, script_path))

    iosPIDList = [ ]
    #iosPIDList = [3286]
    for pid in iosPIDList:
        apps_configs.append((host_name, "",pid, spawn, script_path))

    print "int_opts:{0}\t{1}\t{2}\t{3}".format(apps_configs, platform,list_apps,output_dir)
    return apps_configs, platform, list_apps, output_dir





 

def main():
    apps_configs =[]
    platfrom=''
    list_apps=0
    output_dir=''
    beginTime = datetime.now()
    print colored('\r\n\t\t\tTrendMicro iOS dynamic sandbox Trace System \r\n\t\t\tsilvermoonsecurity, moony @Flyic 2017 %s\r\n\r\n' % (time.strftime('%b %d %Y %l:%M %p', time.localtime())), 'red')

    apps_configs, platform, list_apps, output_dir = init_opts()
    #__init__(self,host_name,app_name, pid=None,platform='',spawn=0, script_path='', output_dir=''):
    
    tracers = []
    for index in range(len(apps_configs)):
        tracers.append(Tracer())
        (host_name, app_name,pid, spawn, script_path) = apps_configs[index]
        tracers[index].init(host_name, app_name,pid,platform,spawn, script_path, output_dir) 
        tracers[index].start()

    #keep main thread busy
    try:
        while True:
            pass
            #continue
            for index in range(len(tracers)):
                if tracers[index].terminated:
                    tracers[index].start()

            pass
    except KeyboardInterrupt:

        for index in range(len(tracers)):
            tracers[index].stop()
        #time.sleep(5)
        endTime = datetime.now()
        print colored("\r\n\t\t\tTrace system consuming: %d seconds"%((endTime-beginTime).seconds),'red')
        print colored('\t\t\tGoodbye! TrendMicro iOS dynamic sandbox Trace System \r\n\t\t\tsilvermoonsecurity, moony @Flyic 2017 %s\r\n\r\n' % (time.strftime('%b %d %Y %l:%M %p', time.localtime())), 'red')
        sys.exit(0)

if __name__ == '__main__':
    main()
    #main(system.args)
